\documentclass[11pt]{article}
\usepackage[a4paper, hmargin={2.8cm, 2.8cm}, vmargin={2.5cm, 2.5cm}]{geometry}
\usepackage{eso-pic} % \AddToShipoutPicture
\usepackage{graphicx} % \includegraphics
\usepackage{listings}
\usepackage{setspace}
%\usepackage{thebibliography}

\definecolor{Background}{rgb}{0.98,0.98,0.98}
\lstset{
    numbers=left,
    numberstyle=\footnotesize,
    numbersep=1em,
    xleftmargin=1em,
    framextopmargin=2em,
    framexbottommargin=2em,
    showspaces=false,
    showtabs=false,
    showstringspaces=false,
    frame=l,
    tabsize=4,
    % Basic
    basicstyle=\ttfamily\small\setstretch{1},
    backgroundcolor=\color{Background}
}

\author{
  \Large{Anna Sofie Kiehn and Henriks Urms}
  %\\ \texttt{a.kiehn89@gmail.com} \\ \\
  %\Large{Henriks Urms}
  %\\ \texttt{urmshenrik@gmail.com}
}

\title{
  \vspace{5cm}
  \Huge{Midvejsrapport} \\
  \Large{Compiling TAIL to Futhark}
}

\begin{document}

%% Change `ku-farve` to `nat-farve` to use SCIENCE's old colors or
%% `natbio-farve` to use SCIENCE's new colors and logo.
\AddToShipoutPicture*{\put(0,0){\includegraphics*[viewport=0 0 700 600]{include/natbio-farve}}}
\AddToShipoutPicture*{\put(0,602){\includegraphics*[viewport=0 600 700 1600]{include/natbio-farve}}}

%% Change `ku-en` to `nat-en` to use the `Faculty of Science` header
\AddToShipoutPicture*{\put(0,0){\includegraphics*{include/nat-en}}}

\clearpage\maketitle
\thispagestyle{empty}

\newpage

\abstract

\newpage

\tableofcontents

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%  REPORT STARTS HERE  %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
The TAIL operators that we will compile to code using the parallel SOACs of Futhark are: each, reduce and zipWith.

\section{TAIL}
TAIL is a typed array intermidiate language and the target of an APL compiler. APL is an older laguage created in the 1960's by Kenneth E. Iverson. APL is an array programming language, its main type is the multi-dimentional array. All of its build-in functions or operators are represented by special graphic symbols allowing for very concise code, it is dynamicly typed and support  first and second order functions. APL supports polymophism in both its first and second order functions and operators. Even though it is not a new language it is still used in the financial world where large code bases are still operational and activly developed. \\

TAIL was designed with the purpose of targeting parallel architectures, though no parallel backend for TAIL yet exists. TAIL can also be compiled efficiently into a C-like language \cite{Elsman0}. \\

The expressivity of TAILs type system allows the compiler to express some operators wich are primitive in APL such as the inner product operator using simpler operators. \\

The central type in taiil is the multi-dimentional array type. Array types consist of a base type and a rank. The base type of an array is the type of the elements in the array.  The currently supported base types are {\tt int}, {\tt double}, {\tt bool} {\tt char}. Scalars are arrays of rank 0. Most operators i TAIL are polymorphic in respect to array ranks and base types. 

Certain operators (such as shape) produce one dimensional array for wich the length is known at compile time. The types of such values are captured in a special vector type that keep track of the vector sizes. 
TAIL include special operators that operate on vectors and peserve this type information. 

The explicit types of TAIL is used to compile away some operators of APL, instead substituting them with simpler APL functions. \\

TAIL program always consist of a single expression. SEE ARTICLE FOR REFERENCE \\

Below we discuss some selected operators from TAIL.

{\tt each} takes as arguments a kernel and an array and functions as the generel map, applying the kernel to each element in the flattened array. 
{\tt eachV} is a special case of {\tt each} ...\\
{\tt reduce} takes as arguments a kernel, a neural element and and array. It works similar to fold in ML starting by aplying the kernel to the neural element and the first element of the array and then the continuesly the kernel applied to the result and the next element in the array. 
{\tt zipWith} takes a kernel and two arrays. It then applies the kernel on the censecutive pair of elements consisting of the i-th element from the first array and the i-th element from the second array. 

%The types in TAIL are devided into four types. Firstly there are base types comsisting of {\tt int}, {\tt double}, {\tt bool} and the polymorphic type {\tt $\alpha$} that can represent any one of them. Secondly, there are shape types that can be either a scalar value/variable of type int,  or a shape variable or a combination of two shape variables. \\
%Then there is array types that consist of a base type and a rank. Finaly there is 


%The main datatype in TAIL is also a multidimantional array. Array types are in TAIL annotated with their ranks explicetly. 
%TAILs type system treats scalar values as special cases of the array time namly an array with rank 0. 

%There are two seperate representations of vectors, either the special vector type used when the length of the vector is known or the general array type where the rank is 1.  
 
%Besides array and vector types, TAIL also have base types in the form of {\tt int}, {\tt double}, {\tt bool} and {\tt $\alpha$}.

%So far TAIL only support a subset of the APL functions and operators. 


\section{Futhark}

Futhark is a functional programming language inspired by Haskell and Standard ML. It was designed to be an atratice choise for expressing complex programs by having enogh expressive power without loosing the posibility to do agressive optimization and creating parallelisation even though the higher the expressive power of the language the more difficult optimization ofthen become. Due to this the Futhark language only support regular arrays (arrays where all inner dimentions are of the same length) because of the complication to size analysis supporting non-regular arrays would create.
However Futhark do support nested parallalism as this is a feature many programs depend upon \cite{Henriksen}.\\

Futhark is a mostly first order language but support bulk (parallel) operations on arrays using the build-in second-order array combinators (SOACs) of the language. The SOACs consist of {\tt map}, {\tt filter}, {\tt reduce} and {\tt scan}. The language is expressive enought that the same functionality as these functions present can be created using do-loops but that should be avoided do to the fact that the optimization Futhark make available are based on the transformation on these.

%Does not support polymorfism in types

%A Futhark program consist of a list of function declarations

\section{The differences between TAIL and futhark}

Her skal vi forklare essensen af problemet ved at compilere tail kode til futhark kode. Dette afsnit er sindsygt vigtigt i forhold til at være overbevisende om at vores projekt er interessant. 

\subsection{Polymorphism}

\section{Compilation strategy}
As mentiont previusly a Tail program always consist of one single expression, whereas a Futhark program is a list of function declarations. The Tail expression is therefore translated/compiled to a Futhark expression by making it the body of the Futhark function. 
Thus the chalenge boils down to translating Tail expressions to Futhark expressions. 
There are 10 different kind of Tail expressions most of whitch has exact equivalents in the Futhark language. This includes but are not limited to, veriables, let ecpressions and litterals. Thus the interesting case is really if the expression is an operator expression. \\

These operators consist of the scalar operators: add, addi, subi, subd, multi, multd, mini, mind, maxi, maxd, andb, orb, xorb, nandb, norb, notb, lti, ltd, ltei, lted, gti, gtd, gtei, gted, eqi, eqd, negi, negd, i2d and b2i, and the array operators: iotaV, iota, eachV, each, reduce(V), reduce, shapeV, shape, reshape, reshape0, reverse, vreverse, rotateV, vrotateV, rotate, transp, transp2, takeV, take, dropV, drop, consV, cons, snocV, snoc, firstV, first, zipWith, catV and cat. \\

The scalar operators have equivalents in the Futhark language and are therefore straight forward to compile. Some of the Tail array operators also have eqivalent or almost eqivalent counterparts in the Futhark laguage but most have not and are therefore interesting to take a closer look at.

\section{The parallel operators}

\subsection{each}

The type of the {\tt each} function is $each(f,a) :: \forall\alpha\beta\gamma.(\alpha \to \beta) \to [\alpha]^\gamma \to [\beta]^\gamma$.

The {\tt each} function in TAIL applies a function to every element in the flat representation of the array. This is a completely parallel operation more commonly known as map. The {\tt map} combinator in futhark has slightly different semantics.
Since futhark views a multidimensional array as nested simple arrays it applies the function to every array element.
Thas is, it maps the function into the outer-most dimention of the array.

To solve this problem we have nested {\tt map}s to the depth of the array with the required function, for example, an {\tt each} operation over an array of rank 2 would have two {\tt map}s nested in each other so the kernel is mapped on each element of basic type.

For example an each operation on an array of rank 2 will look like:
\begin{lstlisting}[numbers=none,frame=none]
each(f,a)	=>	map(fn x => map (f,x), a)
\end{lstlisting}

This means the parallel {\tt each} operations in TAIL are compiled to parallel code in the futhark language.

\subsection{eachV}
The {\tt eachV } is just a special case of the {\tt each} operator that works on vectors, i.e. flat arrays where the size
is known at compile time. We do not use this extra information so this special case is not important for us.

\subsection{reduce}
The type of the {\tt each} function is $reduce(f,id,a) :: \forall\alpha\gamma.(\alpha \to \alpha \to \alpha) \to \alpha \to [\alpha]^{\gamma+1} \to [\alpha]^\gamma$.
The {\tt reduce} function in TAIL uses an associative binary operator to reduce an array of rank $\gamma+1$ to an array of rank $\gamma$ by reducing along the inner-most dimension. The futhark reduce on the other hand reduces each array in the outer array, i.e. it reduces along the outer-most dimension. 

We have adopted the samme approach as with each by using nested maps to map the reduce on the innermost dimension.

Fore example reducing an array of rank 2 emits the following code:

\begin{lstlisting}[numbers=none,frame=none]
reduce(+,a)	=> 	map(fn x => reduce(+,x), a)
\end{lstlisting}

\subsection{zipWith}

The zipWith operator applies a scalar binary operator on pairs of elements from two arrays of the same shape two
produce a third array of the same shape as the input arrays.

 To do this in futhark we use the zip function to convert two arrays to an array of tuples and map the binary operator on that array of tuples.

\section{Other interesting operators}

Beside the parallel operators there are other operators worth mentioning mostly because of non trivial semantics.  

\subsection{reshape}

The reshape operator also has quite unique semantics in TAIL, if the dimensions of reshape don't match the dimensions of the array, the
array is either truncated or the elements are repeated until the array is long enough.

Futhark has a reshape function that only works for arrays of the correct dimensions.

Our general strategy for compiling reshape is to first ensure that the array is the correct size and then use the futhark reshape
function to do the final step. To adjust the size we operate on the flat representation of the array, this is easy to produce also
using futhark reshape. To adjust the array we first make sure it is long enough by extending it using the function replicate and then
truncate it to the correct length with split.

To keep the implementation simple we generate code that calls generated library functions written in futhark which do most of the work.
Nevertheless we inline the flattening and reshaping code so we only need reshape functions written in futhark
for the one dimensional cases. If we wanted to simply call a function instead we would need a seperate library function for each
rank and basic type combination which we needed to call reshape on since futhark only allows declaration of monomorphic functions.

We have to decide where to put the library functions.
We would like the compiler to always output a valid (runnable) futhark program given a valid TAIL input program, so we would like to
be able to include the library in the output when we run the compiler.
Furthermore since futhark has no polymorphism we have to include versions of all types, but we would like to only maintain one version.
Finally since Funthark is eventually expected to feature polymorphism and a module system we would like the solution to not be too
extensive. Therefore we have coded the functions in the compiler itself.

We have used this approach throughout our compiler, e.g. the take operator is implemented similarily.
\subsection{take} 

The {\tt take} operator in TAIL has very unique semantics, for a positive arguement that is less than the size of the array it behaves as one would suspect i.e. it returns the first n elements of the array. For a negative argument {\tt take} returns the last n elements of the array. If there are not enough elements in the array, {\tt take} pads with zeros.

In a similar fashion to reshape we have used library functions do most of the work.
We flatten the array, let the library function work on the flat representation and finally reshape it to the desired shape.
This approach has all the benifits mentioned earlier.

\section{Implementation of the compiler}

\section{Testing}

\section{Discussion}

\section{Summery and future work}

\section{Methods and tools}

cabal\\
git\\
\subsection{Test}
We have decided on making integration test testing the pipeline all the ray from apl through TAIL to futhark.
golden, \\

\section{Project status}
The project is comming along as planed. We used the fist couple of weeks after handing in the synopsis to get a more detailed understanding of the TAIL and futhark and began creating the framework we wanted to use for the compiler. 
We thought it would take longer time adapting the parser to work with the new version of TAIL than it did and therefore ended up starting on the acutal compiler about 3 days ahed of time. 

We are creently about half way with the implementation of the functions in TAIL. We have done testing from the beginning but 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% REFERENCES / LITTERATURE %%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% in order to make a reference use \cite[]{} exaple \cite[p.~2]{Henriksen} referes to page 2 in Troels' MSc thesis
\begin{thebibliography}{widest entry}

  \bibitem[1]{Elsman0} Martin Elsman and Martin Dybdal. \textbf{Compiling a Subset of APL Into a Typed Intermediate Language} In ACM SIGPLAN International Workshop on Libraries, Languages and Compilers for Array Programming (ARRAY’14). Edinburgh, UK. June, 2014

  \bibitem[2]{Henriksen} Troels Henriksen. \textbf{Exploiting Functional Invariants to Optimise Parallelism: a dataflow approach}.\\   MSc thesis. Department of Computer Science, University of Copenhagen. February 2014.
  

\end{thebibliography}

\end{document}
